function cmCorr = calccmarr(fileGroup, params)
%CALCCMARR Calculates the causality metrics for the
%island represented by fileGroup. 
%  Returns an n x n matrix of ones and zeros representing where ones
%  denote positive causality between the two spikes.

spikeCountArr = countspikes(fileGroup); % put spikes of file into an array
nRoi = numel(spikeCountArr); % nRoi is number of spikes
cmCorr = zeros(nRoi);
lag = [];
for roi1 = 1:nRoi
    for roi2 = (roi1+1):nRoi
        [cmCorrArr, lagArrMs, seconds, K0] = calccmcorr(fileGroup, roi1, roi2, params);
        K0 = sum(K0);
        poissResults = poisscdf(cmCorrArr, K0);
        if poissResults > 1 - params.alphaThreshold
            cmCorr(roi1,roi2) = 1;
        end
    end
end


function [totals, lagArrMs, seconds, totals0] = calccmcorr(fileGroup, roi1, roi2, params)
maxLagMs = params.monoMaxLagMs;
zeroLagMs = params.monoZeroLagMs;
totals = 0;
totals0 = 0;
totalFrames = 0;
totalLagArr = [];
for iFile = 1:numel(fileGroup)
    spikeFile = fileGroup{iFile};
    load(spikeFile, 'spikeDataArray', 'frameRate');
    nFrame = numel(spikeDataArray{1}.dffs);
    totalFrames = (totalFrames + nFrame) * numel(fileGroup);
    cmCorrMaxLagFrame = round(maxLagMs*frameRate/1000);
    cmCorr0LagFrame = round(zeroLagMs*frameRate/1000);

    spikeVec1 = times2vector(spikeDataArray{roi1}.rasterSpikeTimes, nFrame);
    spikeVec2 = times2vector(spikeDataArray{roi2}.rasterSpikeTimes, nFrame);
    
    [currcmcorrArrB, lagArr] = xcorr(spikeVec1, spikeVec2, cmCorrMaxLagFrame);
    [K0Arr, lagArr0] = xcorr(spikeVec1, spikeVec2, cmCorr0LagFrame);
    totalLagArr = [totalLagArr lagArr];
    totals = totals + currcmcorrArrB;
    totals0 = totals0 + K0Arr;
end


%convert from frames back to Ms
lagArrMs = totalLagArr ./ frameRate .* 1000;
seconds = totalFrames / frameRate;



function sumArr = addarr(arr1,arr2)
if isempty(arr1)
    sumArr = arr2;
else
    sumArr = arr1+arr2;
end


function spikeVector = times2vector(spikeTimes, nFrame)
spikeVector = zeros(1,nFrame);
spikeVector(spikeTimes) = 1;
